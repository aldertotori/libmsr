/* README
 *
 * Copyright (c) 2011, 2012, 2013, 2014, 2015 by Lawrence Livermore National Security, LLC. LLNL-CODE-645430
 * Produced at the Lawrence Livermore National Laboratory.
 * Written by Kathleen Shoga and Barry Rountree (shoga1|rountree@llnl.gov).
 * All rights reserved.
 *
 * This file is part of libmsr.
 *
 * libmsr is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any
 * later version.
 *
 * libmsr is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along
 * with libmsr. If not, see <http://www.gnu.org/licenses/>.
 *
 * This material is based upon work supported by the U.S. Department
 * of Energy's Lawrence Livermore National Laboratory. Office of
 * Science, under Award number DE-AC52-07NA27344.
 *
 */

Contents:

1.  A gentle introduction to model-specific registers
2.  Prerequisites
3.  msr_core
99. References
	


1.  A gentle introduction to model-specific registers

Back in the days of the 80386, Intel began adding specific registers
to expose additional processor features.  Eventually the interface
to these registers standardized on the privileged "rdmsr" and "wrmsr"
assembly language instructions, which each instruction taking an msr
"address" and either reading or writing a value to the address,
respectively.  For details of how these two instructions work, see
[1]:4-291,4-559.

The msr interface has evolved to cover a wide array of additional
functionality.  Hardware performance counters are exposed via msrs,
for example, as well, as much of the power and thermal sensors and
control.  However, many msrs have significant security implications
(e.g., holding the pointer to the kernel interrupt vector).  

The stock linux msr kernel provides an interface in the /dev/cpu/*/msr
set of files.  The file IO interface uses pread() and pwrite() as
follows:

pread( file_desc, (uint64_t*)val, (size_t)sizeof(uint64_t), msr_addr);
pwrite(file_desc, (uint64_t*)val, (size_t)sizeof(uint64_t), msr_addr);

Most of the msrs of interest are described in volume 3 of the Intel
documentation[2], particularly chapters 14 (Power and Thermal Management)
and 17 (Debug, Branch Profile, TSC and Resoruce Monitoring features).
The addresses for each msr are listed in the appendicies of volume 3C.
Note that msrs may be per-package (aka CPU or socket), per core or per
hardware thread.

There are no interfaces to msrs beyond writing a value and observing
the results.  In particular, there are no error codes. An incorrect
bitstring may be ignored by the processor, overwritten or cause the
machine to lock up or reboot.  Given the minimal documentation available,
using msrs can be a particularly frustrating challenge.  Part of the 
purpose of libmsr is to provide a higher-level API that will free most
users from having to parse individual bit strings.



2.  Prerequisites

As mentioned above, rdmsr and wrmsr must execute in ring 0, which for 
most environments means that they will execute in kernel space.  In 
linux, a filesystem interface is provided via the msr kernel module.
If the module is successfully loaded or compiled in, the following 
files are created:

	/dev/cpu/0/msr
	/dev/cpu/1/msr
	...

There is one file per hardware thread (or, if hyperthreading is not
enabled, one file per core).  Given two threads per core and four
cores per package, a package-level msr on cpu 0 may be accessed 
via any of /dev/cpu/0/msr, ..., /dev/cpu/7/msr.  Addressing core 0
may be done via /dev/cpu/0/msr or /dev/cpu/1/msr.  Thread-specific
msrs must use the appropriate file.

There are two serious drawbacks to using the stock kernel module.
First, it is trivial for a user to root the machine if the user can
write to any msr file, and even read-only access may leak sensitive
information. Second, filesystem permissions may be inadequate to keep
out a sophisticated attacker.  Recent kernels have included a capabilities
check in addition to the existing filesystem permissions check.  The 
capabilities check was a remarkably poor design decision.  In controlled
environments, the msr files could no longer be set to have group 
permissions shared by a subset of trusted users.  These users (or their
binaries) now had to have additional capabilties that were not limited
to reading and writing msrs.[2]  

An alternative is the msr-safe kernel module.[3]  This module generates
files /dev/cpu/0/msr_safe, ... and duplicates the interface used by the
stock kernel module, with two exceptions.  First, no capabilities check
in performed.  Second, access is provided only to whitelisted msrs.  This
allows access to the msr_safe files to be controlled via filesystem 
permissions and access provided to most (and potentially all) users.



3.  msr_core

This file is a set of thin wrappers for directly reading and writing 
msrs.  Most users should not need to access these functions and should
instead use the higher-level APIs provided.

	init_msr()

		Must be called before any other function in libmsr.  
		Will attempt to bind to (in order) msr_dev, msr_safe 
		and finally msr files.  (msr_dev is expected to be a 
		site-specific development or debugging interface.)  
		The function checks for existence, rw permissions and
		success in opening the files.  No checks are made for 
		capabilities.

		The most common causes for errors are:

		1)  forgetting to load the msr or msr_safe kernel modules
		2)  not setting appropriate file permissions on the files
		3)  using the stock msr module without setting capabilities
			or not running as root


	finalize_msr()
	
		Closes the file descriptors.  No calls in libmsr 
		should be made after this function is called.


	read_msr_by_idx(  int dev_idx, off_t msr, uint64_t *val );
	write_msr_by_idx( int dev_idx, off_t msr, uint64_t  val );

		These APIs call into the kernel interface.  Translating
		packages, cores and threads into their correct device
		index is error-prone.  Even for writing particular msrs,
		a higher-level interface should almost always be used.
		All the other functions below are wrappers for these
		two functions.

	read_msr_by_coord(  int socket, int core, int thread, off_t msr, uint64_t *val );
	write_msr_by_coord( int socket, int core, int thread, off_t msr, uint64_t  val );

		Read/write individual msrs.  For a higher granularity, 
		specify zeros for all lower granularities (e.g., writing
		to core 3 of socket 1 is accomplished by setting socket=1,
		core=3 and thread=0).  

	read_all_threads(    off_t msr, uint64_t *val );
	read_all_cores(      off_t msr, uint64_t *val );
	read_all_sockets(    off_t msr, uint64_t *val );

		Iterates over the set of all specific devices.  Note that
		NUM_SOCKETS, NUM_CORES_PER_SOCKET and NUM_THREADS_PER_CORE
		are defined in msr_core.h, as are the derivative macros
		NUM_DEVS, NUM_CORES and NUM_THREADS.  The pointer provided
		by the user must point to memory large enough to hold the
		values read from all requested msrs.

	write_all_threads(   off_t msr, uint64_t  val );
	write_all_cores(     off_t msr, uint64_t  val );
	write_all_sockets(   off_t msr, uint64_t  val );
	
		Writes value val to all specified msrs.	

	write_all_threads_v( off_t msr, uint64_t *val );
	write_all_cores_v(   off_t msr, uint64_t *val );
	write_all_sockets_v( off_t msr, uint64_t *val );

		Writes the array pointed to by val to the specified msrs.
		Use this when each msr needs to receive a unique value.

99. References

[1] Intel 64 and IA-32 Architectures Software Developer Manual Volume 
2B: Instruction Set Reference, N-Z.  Order Number: 253667-053US
January 2015.
http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b-manual.pdf

[2] Michael Kerrisk, "The trouble with CAP_SYS_RAWIO".  Linux Weekly News, March 13, 2013.  https://lwn.net/Articles/542327/

[3] https://github.com/scalability-llnl/msr-safe
